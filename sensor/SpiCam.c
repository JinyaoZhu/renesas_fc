#include "SpiCam.h"

#define blocksize 5
#define blockmask 0x1f

extern volatile uint8_t * gp_csi20_rx_address;         /* csi20 receive buffer address */
extern volatile uint16_t  g_csi20_rx_count;            /* csi20 receive data count */
extern volatile uint8_t * gp_csi20_tx_address;         /* csi20 send buffer address */
extern volatile uint16_t  g_csi20_tx_count;            /* csi20 send data count */
extern volatile uint16_t  g_csi20_send_length;         /* csi20 send data length */
extern volatile uint16_t g_csi20_rx_end;

unsigned char bbuf[30 * 4];
unsigned short bptr = 0;
unsigned char bmask = 1, xpos = 0;

uint8_t Buffer[1024] = {0};

unsigned char bx, by, ly, ly2, lcx;
volatile unsigned char valavg=0,valmax=0,valmin=255;

const unsigned char bitmap[] = {
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
  0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,
  0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
  0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00
};

volatile const unsigned char vignetemask[] = {
  0x47, 0x4A, 0x4F, 0x54, 0x5A, 0x60, 0x65, 0x6A, 0x6F, 0x73, 0x76, 0x7A, 0x7C, 0x7E, 0x7F, 0x7F,
  0x7E, 0x7C, 0x7A, 0x76, 0x73, 0x6F, 0x6A, 0x65, 0x60, 0x5A, 0x54, 0x4F, 0x4A, 0x47, 0x4C, 0x50,
  0x55, 0x5B, 0x61, 0x67, 0x6D, 0x72, 0x77, 0x7B, 0x7E, 0x82, 0x84, 0x86, 0x87, 0x87, 0x86, 0x84,
  0x82, 0x7E, 0x7B, 0x77, 0x72, 0x6D, 0x67, 0x61, 0x5B, 0x55, 0x50, 0x4C, 0x52, 0x56, 0x5C, 0x63,
  0x69, 0x6F, 0x76, 0x7B, 0x80, 0x85, 0x88, 0x8B, 0x8E, 0x90, 0x91, 0x91, 0x90, 0x8E, 0x8B, 0x88,
  0x85, 0x80, 0x7B, 0x76, 0x6F, 0x69, 0x63, 0x5C, 0x56, 0x52, 0x58, 0x5D, 0x64, 0x6A, 0x71, 0x78,
  0x7E, 0x84, 0x8A, 0x8E, 0x92, 0x96, 0x98, 0x9A, 0x9B, 0x9B, 0x9A, 0x98, 0x96, 0x92, 0x8E, 0x8A,
  0x84, 0x7E, 0x78, 0x71, 0x6A, 0x64, 0x5D, 0x58, 0x5E, 0x63, 0x6A, 0x71, 0x79, 0x80, 0x86, 0x8D,
  0x92, 0x98, 0x9C, 0x9F, 0xA2, 0xA4, 0xA5, 0xA5, 0xA4, 0xA2, 0x9F, 0x9C, 0x98, 0x92, 0x8D, 0x86,
  0x80, 0x79, 0x71, 0x6A, 0x63, 0x5E, 0x64, 0x69, 0x70, 0x78, 0x80, 0x88, 0x8E, 0x95, 0x9B, 0xA0,
  0xA4, 0xA8, 0xAB, 0xAD, 0xAE, 0xAE, 0xAD, 0xAB, 0xA8, 0xA4, 0xA0, 0x9B, 0x95, 0x8E, 0x88, 0x80,
  0x78, 0x70, 0x69, 0x64, 0x69, 0x6E, 0x76, 0x7E, 0x87, 0x8E, 0x96, 0x9D, 0xA3, 0xA8, 0xAD, 0xB0,
  0xB3, 0xB5, 0xB6, 0xB6, 0xB5, 0xB3, 0xB0, 0xAD, 0xA8, 0xA3, 0x9D, 0x96, 0x8E, 0x87, 0x7E, 0x76,
  0x6E, 0x69, 0x6D, 0x74, 0x7B, 0x84, 0x8C, 0x94, 0x9C, 0xA4, 0xAA, 0xB0, 0xB4, 0xB8, 0xBA, 0xBC,
  0xBD, 0xBD, 0xBC, 0xBA, 0xB8, 0xB4, 0xB0, 0xAA, 0xA4, 0x9C, 0x94, 0x8C, 0x84, 0x7B, 0x74, 0x6D,
  0x72, 0x78, 0x80, 0x89, 0x92, 0x9B, 0xA3, 0xAA, 0xB0, 0xB6, 0xBA, 0xBD, 0xC0, 0xC1, 0xC2, 0xC2,
  0xC1, 0xC0, 0xBD, 0xBA, 0xB6, 0xB0, 0xAA, 0xA3, 0x9B, 0x92, 0x89, 0x80, 0x78, 0x72, 0x75, 0x7C,
  0x84, 0x8E, 0x97, 0xA0, 0xA8, 0xB0, 0xB6, 0xBB, 0xBE, 0xC1, 0xC4, 0xC4, 0xC5, 0xC5, 0xC4, 0xC4,
  0xC1, 0xBE, 0xBB, 0xB6, 0xB0, 0xA8, 0xA0, 0x97, 0x8E, 0x84, 0x7C, 0x75, 0x78, 0x7F, 0x88, 0x92,
  0x9B, 0xA4, 0xAC, 0xB4, 0xBA, 0xBE, 0xC2, 0xC4, 0xC6, 0xC6, 0xC7, 0xC7, 0xC6, 0xC6, 0xC4, 0xC2,
  0xBE, 0xBA, 0xB4, 0xAC, 0xA4, 0x9B, 0x92, 0x88, 0x7F, 0x78, 0x7C, 0x82, 0x8B, 0x94, 0x9E, 0xA8,
  0xB0, 0xB7, 0xBD, 0xC1, 0xC4, 0xC6, 0xC7, 0xC8, 0xC8, 0xC8, 0xC8, 0xC7, 0xC6, 0xC4, 0xC1, 0xBD,
  0xB7, 0xB0, 0xA8, 0x9E, 0x94, 0x8B, 0x82, 0x7C, 0x7E, 0x84, 0x8D, 0x97, 0xA1, 0xAA, 0xB3, 0xBA,
  0xBF, 0xC3, 0xC6, 0xC7, 0xC8, 0xC9, 0xC9, 0xC9, 0xC9, 0xC8, 0xC7, 0xC6, 0xC3, 0xBF, 0xBA, 0xB3,
  0xAA, 0xA1, 0x97, 0x8D, 0x84, 0x7E, 0x7E, 0x86, 0x8E, 0x98, 0xA2, 0xAC, 0xB4, 0xBC, 0xC1, 0xC4,
  0xC6, 0xC8, 0xC9, 0xCA, 0xCA, 0xCA, 0xCA, 0xC9, 0xC8, 0xC6, 0xC4, 0xC1, 0xBC, 0xB4, 0xAC, 0xA2,
  0x98, 0x8E, 0x86, 0x7E, 0x7F, 0x86, 0x8E, 0x99, 0xA3, 0xAD, 0xB6, 0xBC, 0xC2, 0xC5, 0xAC, 0xC8,
  0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xCA, 0xC8, 0xC8, 0xC5, 0xC2, 0xBC, 0xB6, 0xAD, 0xA3, 0x99, 0x8E,
  0x86, 0x7F, 0x7F, 0x86, 0x8E, 0x99, 0xA3, 0xAD, 0xB6, 0xBC, 0xC2, 0xC5, 0xC8, 0xC8, 0xCA, 0xCA,
  0xCA, 0xCA, 0xCA, 0xCA, 0xC8, 0xC8, 0xC5, 0xC2, 0xBC, 0xB6, 0xAD, 0xA3, 0x99, 0x8E, 0x86, 0x7F,
  0x7E, 0x86, 0x8E, 0x98, 0xA2, 0xAC, 0xB4, 0xBC, 0xC1, 0xC4, 0xC6, 0xC8, 0xC9, 0xCA, 0xCA, 0xCA,
  0xCA, 0xC9, 0xC8, 0xC6, 0xC4, 0xC1, 0xBC, 0xB4, 0x8D, 0xA2, 0x98, 0x8E, 0x86, 0x7E, 0x7E, 0x84,
  0x8D, 0x97, 0xA1, 0xAA, 0xB3, 0xBA, 0xBF, 0xC3, 0xC6, 0xC7, 0xC8, 0xC9, 0xC9, 0xC9, 0xC9, 0xC8,
  0xC7, 0xC6, 0xC3, 0xBF, 0xBA, 0xB3, 0xAA, 0xA1, 0x97, 0x8D, 0x84, 0x7E, 0x7C, 0x82, 0x8B, 0x94,
  0x9E, 0xA8, 0xB0, 0xB7, 0xBD, 0xC1, 0xC4, 0xC6, 0xC7, 0xC8, 0xC8, 0xC8, 0xC8, 0xC7, 0xC6, 0xC4,
  0xC1, 0xBD, 0xB7, 0xB0, 0xA8, 0x9E, 0x94, 0x8B, 0x82, 0x7C, 0x78, 0x7F, 0x88, 0x92, 0x9B, 0xA4,
  0xAC, 0xB4, 0xBA, 0xBE, 0xC2, 0xC4, 0xC6, 0xC6, 0xC7, 0xC7, 0xC6, 0xC6, 0xC4, 0xC2, 0xBE, 0xBA,
  0xB4, 0xAC, 0xA4, 0x9B, 0x92, 0x88, 0x7F, 0x78, 0x75, 0x7C, 0x84, 0x8E, 0x97, 0xA0, 0xA8, 0xB0,
  0xB6, 0xBB, 0xBE, 0xC1, 0xC4, 0xC4, 0xC5, 0xC5, 0xC4, 0xC4, 0xC1, 0xBE, 0xBB, 0xB6, 0xB0, 0xA8,
  0xA0, 0x97, 0x8E, 0x84, 0x7C, 0x75, 0x72, 0x78, 0x80, 0x89, 0x92, 0x9B, 0xA3, 0xAA, 0xB0, 0xB6,
  0xBA, 0xBD, 0xC0, 0xC1, 0xC2, 0xC2, 0xC1, 0xC0, 0xBD, 0xBA, 0xB6, 0xB0, 0xAA, 0xA3, 0x9B, 0x92,
  0x89, 0x80, 0x78, 0x72, 0x6D, 0x74, 0x7B, 0x84, 0x8C, 0x94, 0x9C, 0xA4, 0xAA, 0xB0, 0xB4, 0xB8,
  0xBA, 0xBC, 0xBD, 0xBD, 0xBC, 0xBA, 0xB8, 0xB4, 0xB0, 0xAA, 0xA4, 0x9C, 0x94, 0x8C, 0x84, 0x7B,
  0x74, 0x6D, 0x69, 0x6E, 0x76, 0x7E, 0x87, 0x8E, 0x96, 0x9D, 0xA3, 0xA8, 0xAD, 0xB0, 0xB3, 0xB5,
  0xB6, 0xB6, 0xB5, 0xB3, 0xB0, 0xAD, 0xA8, 0xA3, 0x9D, 0x96, 0x8E, 0x87, 0x7E, 0x76, 0x6E, 0x69,
  0x64, 0x69, 0x70, 0x78, 0x80, 0x88, 0x8E, 0x95, 0x9B, 0xA0, 0xA4, 0xA8, 0xAB, 0xAD, 0xAE, 0xAE,
  0xAD, 0xAB, 0xA8, 0xA4, 0xA0, 0x9B, 0x95, 0x8E, 0x88, 0x80, 0x78, 0x70, 0x69, 0x64, 0x5E, 0x63,
  0x6A, 0x71, 0x79, 0x80, 0x86, 0x8D, 0x92, 0x98, 0x9C, 0x9F, 0xA2, 0xA4, 0xA5, 0xA5, 0xA4, 0xA2,
  0x9F, 0x9C, 0x98, 0x92, 0x8D, 0x86, 0x80, 0x79, 0x71, 0x6A, 0x63, 0x5E, 0x58, 0x5D, 0x64, 0x6A,
  0x71, 0x78, 0x7E, 0x84, 0x8A, 0x8E, 0x92, 0x96, 0x98, 0x9A, 0x9B, 0x9B, 0x9A, 0x98, 0x96, 0x92,
  0x8E, 0x8A, 0x84, 0x7E, 0x78, 0x71, 0x6A, 0x64, 0x5D, 0x58, 0x52, 0x56, 0x5C, 0x63, 0x69, 0x6F,
  0x76, 0x7B, 0x80, 0x85, 0x88, 0x8B, 0x8E, 0x90, 0x91, 0x91, 0x90, 0x8E, 0x8B, 0x88, 0x85, 0x80,
  0x7B, 0x76, 0x6F, 0x69, 0x63, 0x5C, 0x56, 0x52, 0x4C, 0x50, 0x55, 0x5B, 0x61, 0x67, 0x6D, 0x72,
  0x77, 0x7B, 0x7E, 0x82, 0x84, 0x86, 0x87, 0x87, 0x86, 0x84, 0x82, 0x7E, 0x7B, 0x77, 0x72, 0x6D,
  0x67, 0x61, 0x5B, 0x55, 0x50, 0x4C, 0x47, 0x4A, 0x4F, 0x54, 0x5A, 0x60, 0x65, 0x6A, 0x6F, 0x73,
  0x76, 0x7A, 0x7C, 0x7E, 0x7F, 0x7F, 0x7E, 0x7C, 0x7A, 0x76, 0x73, 0x6F, 0x6A, 0x65, 0x60, 0x5A,
  0x54, 0x4F, 0x4A, 0x47
};


const unsigned char lmap[] = {1, 28, 2, 27, 3, 26, 4, 25, 5, 24, 6, 23, 7, 22, 8, 21, 9, 20, 10, 19, 11, 18, 12, 17, 13, 16, 14, 15};
const unsigned long * lmapb = (const unsigned long *)bitmap;

//circle center x y;top bottom ,crossline

void  pushpx(int val)
{
  if (val)
    bbuf[bptr] |= bmask;
  else
    bbuf[bptr] &= (unsigned char)~bmask;
  bmask <<= 1;
  if (!bmask)
  {
    bmask = 1;
    bptr++;
  }
  if (++xpos == 30)
  {
    xpos = 0;
    bptr++;
    bmask = 1;
  }
}

void  resetpx(void)
{
  xpos = 0;
  bptr = 0;
  bmask = 1;
}


MD_STATUS SpiCam_SendRecevied(uint8_t * const tx_buf, uint16_t tx_num, uint8_t * const rx_buf)
{
  return R_CSI20_Send_Receive(tx_buf,tx_num,rx_buf);
}

unsigned char isblock(unsigned char x, unsigned char y)
{

  unsigned short * linebase = (unsigned short *)&bbuf[(y << 2) + (x >> 3)];
  unsigned short tmp = 0;
  unsigned char i = 0;

  for (i = 0; i < blocksize ; i++)
  {
    tmp = (*linebase) >> (x & 0x7);
    if (tmp & blockmask)
      return 0;
    linebase += 2;
  }
  return 1;
}


void findblock(void)
{
  unsigned char x, y, yp;
  unsigned char xmax = 0, xmin = 255, ymax = 0, ymin = 255;
  for (y = 1; y < 29 - blocksize; y++)
    for (x = 1; x < 29 - blocksize; x++)
      if (isblock(x, y))
      {
        if (xmin > x)
          xmin = x;
        if (ymin > y)
          ymin = y;
        if (xmax < x)
          xmax = x;
        if (ymax < y)
          ymax = y;
      }
  if (xmin == 255)
    bx = by = 0;
  else
  {
    bx = (unsigned char)((xmin + xmax + blocksize) >> 1);
    by = (unsigned char)((ymin + ymax + blocksize) >> 1);
  }
}



void findline()
{
  unsigned char x, y, yp;
  unsigned char * pbuf;
  unsigned long ll;
  ly = ly2 = lcx = 0;

  ll = ~((*(unsigned long *)&bbuf[4 * 1]) | (*(unsigned long *)&bbuf[4 * 2]));
  for (y = 0; y < sizeof(lmap); y++)
    if (ll & lmapb[y])
      lcx = lmap[y];

  for (y = 0; y < sizeof(lmap); y++)
  {
    pbuf = &bbuf[lmap[y] << 2];
    if (!(pbuf[0] & 6))
      ly2 = lmap[y];
    if (!(pbuf[3] & 0x18))
      ly = lmap[y];
  }
}


uint8_t GetProductID(void)
{
  Buffer[0] = 0;
  g_csi20_rx_end = 0;
  ANDS3080_CS_PIN = LOW;
  SpiCam_SendRecevied(Buffer, 2, Buffer);
  while (!g_csi20_rx_end);
  ANDS3080_CS_PIN = HIGH;
  return Buffer[1];
}


void FrameCapture(void)
{
  Buffer[0] = 0x13 | 0x80;
  Buffer[1] = 0x83;
  g_csi20_rx_end = 0;
  ANDS3080_CS_PIN = LOW;
  SpiCam_SendRecevied(Buffer, 2, Buffer);
  while (!g_csi20_rx_end);
  ANDS3080_CS_PIN = HIGH;
}


void SpiCam_Update(void)
{
  unsigned char x,y;
  unsigned char val=0xff;
  FrameCapture();
  findblock();
  findline();
  //ly,ly2,lcx,by,bx,valavg
  g_csi20_rx_end = 0;
  ANDS3080_CS_PIN = LOW;
  SpiCam_R_CSI20_GetImage(); /* define in r_cg_serial.c */
  while(!g_csi20_rx_end);	
  ANDS3080_CS_PIN = HIGH;
}


unsigned char SpiCam_GetBx(void)
{
  return bx;
}

unsigned char SpiCam_GetLy(void)
{
  return ly2;
}

unsigned char SpiCam_GetQual(void)
{
  return valavg;
}

/*
*******************************************************************
MD_STATUS SpiCam_R_CSI20_GetImage(void)
{
  MD_STATUS status = MD_OK;

  g_csi20_send_length = 0;
  g_csi20_tx_count = 0;
  gp_csi20_tx_address = 0;
  gp_csi20_rx_address = 0;
  SMR10 |= _0001_SAU_BUFFER_EMPTY;
  CSIMK20 = 1U;
  SIO20 = 0x40;
  CSIMK20 = 0U;
  return (status);
}


void SpiCam_Process(void)
{
  unsigned char tmp;
  unsigned short val;
  //spi image mode
  tmp = SIO20;
  val = (unsigned char)(tmp << 2);
  if (g_csi20_tx_count <= 900)
  {
    SIO20 = 0;
  }
  if (!g_csi20_tx_count)
    //  if((tmp & 0x40) && g_csi11_tx_count<10)
  {
    g_csi20_tx_count = 1;
    resetpx();
    return ;
  }

  if (valmax < val)
    valmax = (unsigned char)val;
  val = (val << 8) / vignetemask[g_csi20_tx_count];
  pushpx(val >= valavg);
  if (g_csi20_tx_count++ > 900)
  {
    valavg = (unsigned char)(valmax / 3); //threshold
    valmax = 0;
    g_csi20_tx_count = 0;
    resetpx();

    SMR10 &= ~_0001_SAU_BUFFER_EMPTY;
    r_csi20_callback_receiveend();
  }
}
*********************************************************************/